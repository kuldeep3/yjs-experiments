{"ast":null,"code":"/**\n * Utility helpers to work with promises.\n *\n * @module promise\n */\nimport * as time from './time.js';\n/**\n * @template T\n * @callback PromiseResolve\n * @param {T|PromiseLike<T>} [result]\n */\n\n/**\n * @template T\n * @param {function(PromiseResolve<T>,function(Error):void):any} f\n * @return {Promise<T>}\n */\n\nexport const create = f =>\n/** @type {Promise<T>} */\nnew Promise(f);\n/**\n * @param {function(function():void,function(Error):void):void} f\n * @return {Promise<void>}\n */\n\nexport const createEmpty = f => new Promise(f);\n/**\n * `Promise.all` wait for all promises in the array to resolve and return the result\n * @template T\n * @param {Array<Promise<T>>} arrp\n * @return {Promise<Array<T>>}\n */\n\nexport const all = arrp => Promise.all(arrp);\n/**\n * @param {Error} [reason]\n * @return {Promise<never>}\n */\n\nexport const reject = reason => Promise.reject(reason);\n/**\n * @template T\n * @param {T|void} res\n * @return {Promise<T|void>}\n */\n\nexport const resolve = res => Promise.resolve(res);\n/**\n * @template T\n * @param {T} res\n * @return {Promise<T>}\n */\n\nexport const resolveWith = res => Promise.resolve(res);\n/**\n * @todo Next version, reorder parameters: check, [timeout, [intervalResolution]]\n *\n * @param {number} timeout\n * @param {function():boolean} check\n * @param {number} [intervalResolution]\n * @return {Promise<void>}\n */\n\nexport const until = function (timeout, check) {\n  let intervalResolution = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;\n  return create((resolve, reject) => {\n    const startTime = time.getUnixTime();\n    const hasTimeout = timeout > 0;\n\n    const untilInterval = () => {\n      if (check()) {\n        clearInterval(intervalHandle);\n        resolve();\n      } else if (hasTimeout) {\n        /* istanbul ignore else */\n        if (time.getUnixTime() - startTime > timeout) {\n          clearInterval(intervalHandle);\n          reject(new Error('Timeout'));\n        }\n      }\n    };\n\n    const intervalHandle = setInterval(untilInterval, intervalResolution);\n  });\n};\n/**\n * @param {number} timeout\n * @return {Promise<undefined>}\n */\n\nexport const wait = timeout => create((resolve, reject) => setTimeout(resolve, timeout));\n/**\n * Checks if an object is a promise using ducktyping.\n *\n * Promises are often polyfilled, so it makes sense to add some additional guarantees if the user of this\n * library has some insane environment where global Promise objects are overwritten.\n *\n * @param {any} p\n * @return {boolean}\n */\n\nexport const isPromise = p => p instanceof Promise || p && p.then && p.catch && p.finally;","map":{"version":3,"names":["time","create","f","Promise","createEmpty","all","arrp","reject","reason","resolve","res","resolveWith","until","timeout","check","intervalResolution","startTime","getUnixTime","hasTimeout","untilInterval","clearInterval","intervalHandle","Error","setInterval","wait","setTimeout","isPromise","p","then","catch","finally"],"sources":["/Users/kuldeepupreti/Downloads/Projects/personal/yjs/node_modules/lib0/promise.js"],"sourcesContent":["/**\n * Utility helpers to work with promises.\n *\n * @module promise\n */\n\nimport * as time from './time.js'\n\n/**\n * @template T\n * @callback PromiseResolve\n * @param {T|PromiseLike<T>} [result]\n */\n\n/**\n * @template T\n * @param {function(PromiseResolve<T>,function(Error):void):any} f\n * @return {Promise<T>}\n */\nexport const create = f => /** @type {Promise<T>} */ (new Promise(f))\n\n/**\n * @param {function(function():void,function(Error):void):void} f\n * @return {Promise<void>}\n */\nexport const createEmpty = f => new Promise(f)\n\n/**\n * `Promise.all` wait for all promises in the array to resolve and return the result\n * @template T\n * @param {Array<Promise<T>>} arrp\n * @return {Promise<Array<T>>}\n */\nexport const all = arrp => Promise.all(arrp)\n\n/**\n * @param {Error} [reason]\n * @return {Promise<never>}\n */\nexport const reject = reason => Promise.reject(reason)\n\n/**\n * @template T\n * @param {T|void} res\n * @return {Promise<T|void>}\n */\nexport const resolve = res => Promise.resolve(res)\n\n/**\n * @template T\n * @param {T} res\n * @return {Promise<T>}\n */\nexport const resolveWith = res => Promise.resolve(res)\n\n/**\n * @todo Next version, reorder parameters: check, [timeout, [intervalResolution]]\n *\n * @param {number} timeout\n * @param {function():boolean} check\n * @param {number} [intervalResolution]\n * @return {Promise<void>}\n */\nexport const until = (timeout, check, intervalResolution = 10) => create((resolve, reject) => {\n  const startTime = time.getUnixTime()\n  const hasTimeout = timeout > 0\n  const untilInterval = () => {\n    if (check()) {\n      clearInterval(intervalHandle)\n      resolve()\n    } else if (hasTimeout) {\n      /* istanbul ignore else */\n      if (time.getUnixTime() - startTime > timeout) {\n        clearInterval(intervalHandle)\n        reject(new Error('Timeout'))\n      }\n    }\n  }\n  const intervalHandle = setInterval(untilInterval, intervalResolution)\n})\n\n/**\n * @param {number} timeout\n * @return {Promise<undefined>}\n */\nexport const wait = timeout => create((resolve, reject) => setTimeout(resolve, timeout))\n\n/**\n * Checks if an object is a promise using ducktyping.\n *\n * Promises are often polyfilled, so it makes sense to add some additional guarantees if the user of this\n * library has some insane environment where global Promise objects are overwritten.\n *\n * @param {any} p\n * @return {boolean}\n */\nexport const isPromise = p => p instanceof Promise || (p && p.then && p.catch && p.finally)\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AAEA,OAAO,KAAKA,IAAZ,MAAsB,WAAtB;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,MAAM,GAAGC,CAAC;AAAI;AAA2B,IAAIC,OAAJ,CAAYD,CAAZ,CAA/C;AAEP;AACA;AACA;AACA;;AACA,OAAO,MAAME,WAAW,GAAGF,CAAC,IAAI,IAAIC,OAAJ,CAAYD,CAAZ,CAAzB;AAEP;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMG,GAAG,GAAGC,IAAI,IAAIH,OAAO,CAACE,GAAR,CAAYC,IAAZ,CAApB;AAEP;AACA;AACA;AACA;;AACA,OAAO,MAAMC,MAAM,GAAGC,MAAM,IAAIL,OAAO,CAACI,MAAR,CAAeC,MAAf,CAAzB;AAEP;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,OAAO,GAAGC,GAAG,IAAIP,OAAO,CAACM,OAAR,CAAgBC,GAAhB,CAAvB;AAEP;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,WAAW,GAAGD,GAAG,IAAIP,OAAO,CAACM,OAAR,CAAgBC,GAAhB,CAA3B;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAME,KAAK,GAAG,UAACC,OAAD,EAAUC,KAAV;EAAA,IAAiBC,kBAAjB,uEAAsC,EAAtC;EAAA,OAA6Cd,MAAM,CAAC,CAACQ,OAAD,EAAUF,MAAV,KAAqB;IAC5F,MAAMS,SAAS,GAAGhB,IAAI,CAACiB,WAAL,EAAlB;IACA,MAAMC,UAAU,GAAGL,OAAO,GAAG,CAA7B;;IACA,MAAMM,aAAa,GAAG,MAAM;MAC1B,IAAIL,KAAK,EAAT,EAAa;QACXM,aAAa,CAACC,cAAD,CAAb;QACAZ,OAAO;MACR,CAHD,MAGO,IAAIS,UAAJ,EAAgB;QACrB;QACA,IAAIlB,IAAI,CAACiB,WAAL,KAAqBD,SAArB,GAAiCH,OAArC,EAA8C;UAC5CO,aAAa,CAACC,cAAD,CAAb;UACAd,MAAM,CAAC,IAAIe,KAAJ,CAAU,SAAV,CAAD,CAAN;QACD;MACF;IACF,CAXD;;IAYA,MAAMD,cAAc,GAAGE,WAAW,CAACJ,aAAD,EAAgBJ,kBAAhB,CAAlC;EACD,CAhBuE,CAAnD;AAAA,CAAd;AAkBP;AACA;AACA;AACA;;AACA,OAAO,MAAMS,IAAI,GAAGX,OAAO,IAAIZ,MAAM,CAAC,CAACQ,OAAD,EAAUF,MAAV,KAAqBkB,UAAU,CAAChB,OAAD,EAAUI,OAAV,CAAhC,CAA9B;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMa,SAAS,GAAGC,CAAC,IAAIA,CAAC,YAAYxB,OAAb,IAAyBwB,CAAC,IAAIA,CAAC,CAACC,IAAP,IAAeD,CAAC,CAACE,KAAjB,IAA0BF,CAAC,CAACG,OAA5E"},"metadata":{},"sourceType":"module"}