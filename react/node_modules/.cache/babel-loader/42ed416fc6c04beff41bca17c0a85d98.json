{"ast":null,"code":"/* eslint-env browser */\n\n/**\n * Tiny websocket connection handler.\n *\n * Implements exponential backoff reconnects, ping/pong, and a nice event system using [lib0/observable].\n *\n * @module websocket\n */\nimport { Observable } from './observable.js';\nimport * as time from './time.js';\nimport * as math from './math.js';\nconst reconnectTimeoutBase = 1200;\nconst maxReconnectTimeout = 2500; // @todo - this should depend on awareness.outdatedTime\n\nconst messageReconnectTimeout = 30000;\n/**\n * @param {WebsocketClient} wsclient\n */\n\nconst setupWS = wsclient => {\n  if (wsclient.shouldConnect && wsclient.ws === null) {\n    const websocket = new WebSocket(wsclient.url);\n    const binaryType = wsclient.binaryType;\n    /**\n     * @type {any}\n     */\n\n    let pingTimeout = null;\n\n    if (binaryType) {\n      websocket.binaryType = binaryType;\n    }\n\n    wsclient.ws = websocket;\n    wsclient.connecting = true;\n    wsclient.connected = false;\n\n    websocket.onmessage = event => {\n      wsclient.lastMessageReceived = time.getUnixTime();\n      const data = event.data;\n      const message = typeof data === 'string' ? JSON.parse(data) : data;\n\n      if (message && message.type === 'pong') {\n        clearTimeout(pingTimeout);\n        pingTimeout = setTimeout(sendPing, messageReconnectTimeout / 2);\n      }\n\n      wsclient.emit('message', [message, wsclient]);\n    };\n    /**\n     * @param {any} error\n     */\n\n\n    const onclose = error => {\n      if (wsclient.ws !== null) {\n        wsclient.ws = null;\n        wsclient.connecting = false;\n\n        if (wsclient.connected) {\n          wsclient.connected = false;\n          wsclient.emit('disconnect', [{\n            type: 'disconnect',\n            error\n          }, wsclient]);\n        } else {\n          wsclient.unsuccessfulReconnects++;\n        } // Start with no reconnect timeout and increase timeout by\n        // log10(wsUnsuccessfulReconnects).\n        // The idea is to increase reconnect timeout slowly and have no reconnect\n        // timeout at the beginning (log(1) = 0)\n\n\n        setTimeout(setupWS, math.min(math.log10(wsclient.unsuccessfulReconnects + 1) * reconnectTimeoutBase, maxReconnectTimeout), wsclient);\n      }\n\n      clearTimeout(pingTimeout);\n    };\n\n    const sendPing = () => {\n      if (wsclient.ws === websocket) {\n        wsclient.send({\n          type: 'ping'\n        });\n      }\n    };\n\n    websocket.onclose = () => onclose(null);\n\n    websocket.onerror = error => onclose(error);\n\n    websocket.onopen = () => {\n      wsclient.lastMessageReceived = time.getUnixTime();\n      wsclient.connecting = false;\n      wsclient.connected = true;\n      wsclient.unsuccessfulReconnects = 0;\n      wsclient.emit('connect', [{\n        type: 'connect'\n      }, wsclient]); // set ping\n\n      pingTimeout = setTimeout(sendPing, messageReconnectTimeout / 2);\n    };\n  }\n};\n/**\n * @extends Observable<string>\n */\n\n\nexport class WebsocketClient extends Observable {\n  /**\n   * @param {string} url\n   * @param {object} [opts]\n   * @param {'arraybuffer' | 'blob' | null} [opts.binaryType] Set `ws.binaryType`\n   */\n  constructor(url) {\n    let {\n      binaryType\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    this.url = url;\n    /**\n     * @type {WebSocket?}\n     */\n\n    this.ws = null;\n    this.binaryType = binaryType || null;\n    this.connected = false;\n    this.connecting = false;\n    this.unsuccessfulReconnects = 0;\n    this.lastMessageReceived = 0;\n    /**\n     * Whether to connect to other peers or not\n     * @type {boolean}\n     */\n\n    this.shouldConnect = true;\n    this._checkInterval = setInterval(() => {\n      if (this.connected && messageReconnectTimeout < time.getUnixTime() - this.lastMessageReceived) {\n        // no message received in a long time - not even your own awareness\n        // updates (which are updated every 15 seconds)\n\n        /** @type {WebSocket} */\n        this.ws.close();\n      }\n    }, messageReconnectTimeout / 2);\n    setupWS(this);\n  }\n  /**\n   * @param {any} message\n   */\n\n\n  send(message) {\n    if (this.ws) {\n      this.ws.send(JSON.stringify(message));\n    }\n  }\n\n  destroy() {\n    clearInterval(this._checkInterval);\n    this.disconnect();\n    super.destroy();\n  }\n\n  disconnect() {\n    this.shouldConnect = false;\n\n    if (this.ws !== null) {\n      this.ws.close();\n    }\n  }\n\n  connect() {\n    this.shouldConnect = true;\n\n    if (!this.connected && this.ws === null) {\n      setupWS(this);\n    }\n  }\n\n}","map":{"version":3,"names":["Observable","time","math","reconnectTimeoutBase","maxReconnectTimeout","messageReconnectTimeout","setupWS","wsclient","shouldConnect","ws","websocket","WebSocket","url","binaryType","pingTimeout","connecting","connected","onmessage","event","lastMessageReceived","getUnixTime","data","message","JSON","parse","type","clearTimeout","setTimeout","sendPing","emit","onclose","error","unsuccessfulReconnects","min","log10","send","onerror","onopen","WebsocketClient","constructor","_checkInterval","setInterval","close","stringify","destroy","clearInterval","disconnect","connect"],"sources":["/Users/kuldeepupreti/Downloads/Projects/personal/yjs/node_modules/lib0/websocket.js"],"sourcesContent":["/* eslint-env browser */\n\n/**\n * Tiny websocket connection handler.\n *\n * Implements exponential backoff reconnects, ping/pong, and a nice event system using [lib0/observable].\n *\n * @module websocket\n */\n\nimport { Observable } from './observable.js'\nimport * as time from './time.js'\nimport * as math from './math.js'\n\nconst reconnectTimeoutBase = 1200\nconst maxReconnectTimeout = 2500\n// @todo - this should depend on awareness.outdatedTime\nconst messageReconnectTimeout = 30000\n\n/**\n * @param {WebsocketClient} wsclient\n */\nconst setupWS = (wsclient) => {\n  if (wsclient.shouldConnect && wsclient.ws === null) {\n    const websocket = new WebSocket(wsclient.url)\n    const binaryType = wsclient.binaryType\n    /**\n     * @type {any}\n     */\n    let pingTimeout = null\n    if (binaryType) {\n      websocket.binaryType = binaryType\n    }\n    wsclient.ws = websocket\n    wsclient.connecting = true\n    wsclient.connected = false\n    websocket.onmessage = event => {\n      wsclient.lastMessageReceived = time.getUnixTime()\n      const data = event.data\n      const message = typeof data === 'string' ? JSON.parse(data) : data\n      if (message && message.type === 'pong') {\n        clearTimeout(pingTimeout)\n        pingTimeout = setTimeout(sendPing, messageReconnectTimeout / 2)\n      }\n      wsclient.emit('message', [message, wsclient])\n    }\n    /**\n     * @param {any} error\n     */\n    const onclose = error => {\n      if (wsclient.ws !== null) {\n        wsclient.ws = null\n        wsclient.connecting = false\n        if (wsclient.connected) {\n          wsclient.connected = false\n          wsclient.emit('disconnect', [{ type: 'disconnect', error }, wsclient])\n        } else {\n          wsclient.unsuccessfulReconnects++\n        }\n        // Start with no reconnect timeout and increase timeout by\n        // log10(wsUnsuccessfulReconnects).\n        // The idea is to increase reconnect timeout slowly and have no reconnect\n        // timeout at the beginning (log(1) = 0)\n        setTimeout(setupWS, math.min(math.log10(wsclient.unsuccessfulReconnects + 1) * reconnectTimeoutBase, maxReconnectTimeout), wsclient)\n      }\n      clearTimeout(pingTimeout)\n    }\n    const sendPing = () => {\n      if (wsclient.ws === websocket) {\n        wsclient.send({\n          type: 'ping'\n        })\n      }\n    }\n    websocket.onclose = () => onclose(null)\n    websocket.onerror = error => onclose(error)\n    websocket.onopen = () => {\n      wsclient.lastMessageReceived = time.getUnixTime()\n      wsclient.connecting = false\n      wsclient.connected = true\n      wsclient.unsuccessfulReconnects = 0\n      wsclient.emit('connect', [{ type: 'connect' }, wsclient])\n      // set ping\n      pingTimeout = setTimeout(sendPing, messageReconnectTimeout / 2)\n    }\n  }\n}\n\n/**\n * @extends Observable<string>\n */\nexport class WebsocketClient extends Observable {\n  /**\n   * @param {string} url\n   * @param {object} [opts]\n   * @param {'arraybuffer' | 'blob' | null} [opts.binaryType] Set `ws.binaryType`\n   */\n  constructor (url, { binaryType } = {}) {\n    super()\n    this.url = url\n    /**\n     * @type {WebSocket?}\n     */\n    this.ws = null\n    this.binaryType = binaryType || null\n    this.connected = false\n    this.connecting = false\n    this.unsuccessfulReconnects = 0\n    this.lastMessageReceived = 0\n    /**\n     * Whether to connect to other peers or not\n     * @type {boolean}\n     */\n    this.shouldConnect = true\n    this._checkInterval = setInterval(() => {\n      if (this.connected && messageReconnectTimeout < time.getUnixTime() - this.lastMessageReceived) {\n        // no message received in a long time - not even your own awareness\n        // updates (which are updated every 15 seconds)\n        /** @type {WebSocket} */ (this.ws).close()\n      }\n    }, messageReconnectTimeout / 2)\n    setupWS(this)\n  }\n\n  /**\n   * @param {any} message\n   */\n  send (message) {\n    if (this.ws) {\n      this.ws.send(JSON.stringify(message))\n    }\n  }\n\n  destroy () {\n    clearInterval(this._checkInterval)\n    this.disconnect()\n    super.destroy()\n  }\n\n  disconnect () {\n    this.shouldConnect = false\n    if (this.ws !== null) {\n      this.ws.close()\n    }\n  }\n\n  connect () {\n    this.shouldConnect = true\n    if (!this.connected && this.ws === null) {\n      setupWS(this)\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}